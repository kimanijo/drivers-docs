---
import { getCollection } from 'astro:content';
import StarlightPage from '@astrojs/starlight/components/StarlightPage.astro';
import yaml from 'js-yaml';
import { readFileSync, existsSync, readdirSync } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url'; // Added fileURLToPath
import { slugify } from '../../utils/slugify';

export async function getStaticPaths() {
  const allDrivers = await getCollection('docs');
  const uniqueCategories = [...new Set(allDrivers.map(driver => slugify(driver.data.category || 'Uncategorized')))];

  return uniqueCategories.map(category => ({
    params: { category: category },
    props: { categoryName: category },
  }));
}

const { category: rawCategory } = Astro.params;
const category = slugify(rawCategory);
const { categoryName } = Astro.props;

const allDrivers = await getCollection('docs');
const driversInCategory = allDrivers.filter(driver => slugify(driver.data.category || 'Uncategorized') === category);

const uniqueManufacturers = new Set();
for (const driver of driversInCategory) {
  const driverId = driver.id; // e.g., drivers/mounts/skywatcher/eqmod
  const driverParts = driverId.split('/');
  const driverCategorySlug = slugify(driverParts[1]); // e.g., mounts
  const driverManufacturerSlug = slugify(driverParts[2]); // e.g., skywatcher
  const driverSlug = slugify(driverParts.pop()); // e.g., eqmod

  // Find the actual cased directory name for the category
  const baseContentDirPath = path.resolve(process.cwd(), `src/content/docs/drivers`);
  let actualCategoryDirName = driverCategorySlug;

  if (existsSync(baseContentDirPath)) {
    const categoryDirs = readdirSync(baseContentDirPath, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .map(dirent => slugify(dirent.name));

    const foundCategoryDir = categoryDirs.find(dir => dir === driverCategorySlug);
    if (foundCategoryDir) {
      actualCategoryDirName = foundCategoryDir;
    } else {
      console.warn(`Actual category directory not found for slug: ${driverCategorySlug}`);
    }
  }

  // Find the actual cased directory name for the manufacturer
  const categoryContentDirPath = path.resolve(process.cwd(), `src/content/docs/drivers/${actualCategoryDirName}`);
  let actualManufacturerDirName = driverManufacturerSlug;

  if (existsSync(categoryContentDirPath)) {
    const manufacturerDirs = readdirSync(categoryContentDirPath, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .map(dirent => slugify(dirent.name));

    const foundManufacturerDir = manufacturerDirs.find(dir => dir === driverManufacturerSlug);
    if (foundManufacturerDir) {
      actualManufacturerDirName = foundManufacturerDir;
    } else {
      console.warn(`Actual manufacturer directory not found for slug: ${driverManufacturerSlug}`);
    }
  }

  const contentDirPath = path.resolve(process.cwd(), `src/content/docs/drivers/${actualCategoryDirName}/${actualManufacturerDirName}`);

  if (existsSync(contentDirPath)) {
    try {
      const filesInDir = readdirSync(contentDirPath);
      const yamlFileName = `${driverSlug}.yaml`;
      const yamlFile = filesInDir.find(file => slugify(file) === slugify(yamlFileName));

      if (yamlFile) {
        const yamlPath = path.resolve(contentDirPath, yamlFile);
        const fileContents = readFileSync(yamlPath, 'utf8');
        const driverInfo = yaml.load(fileContents);
        if (driverInfo && typeof driverInfo === 'object') {
          if ('manufacturer' in driverInfo) {
            uniqueManufacturers.add(slugify(driverInfo.manufacturer));
          } else if ('Manufacturer' in driverInfo) {
            uniqueManufacturers.add(slugify(driverInfo.Manufacturer));
          }
        }
      } else {
        console.warn(`YAML file not found for driver ${driverId} in ${contentDirPath}`);
      }
    } catch (e) {
      console.error(`Error processing YAML for ${driverId}:`, e);
    }
  } else {
    console.warn(`Content directory not found for driver ${driverId}: ${contentDirPath}`);
  }
}

const manufacturers = Array.from(uniqueManufacturers);
---

<StarlightPage frontmatter={{
  title: `${categoryName} Manufacturers`,
  template: 'splash'
}}>
  <div class="manufacturer-grid">
    {manufacturers.map(manufacturer => {
      const manufacturerLink = `/drivers/${category}/${manufacturer}`;
      return (
        <a href={manufacturerLink} class="manufacturer-box">
          <img src={`/images/manufacturers/${manufacturer}.webp`} alt={`${manufacturer} logo`} class="manufacturer-logo" />
          <h2>{manufacturer}</h2>
        </a>
      );
    })}
  </div>
</StarlightPage>

<style>
  .manufacturer-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 1.5rem;
    margin-top: 2rem;
  }

  .manufacturer-box {
    border: 1px solid var(--sl-color-gray-5);
    border-radius: 0.75rem;
    padding: 0.5rem;
    background-color: var(--sl-color-gray-6);
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    text-decoration: none;
    color: inherit;
    box-shadow: var(--sl-shadow-sm);
    transition: all 0.2s ease-in-out;
  }

  .manufacturer-box:hover {
    background-color: var(--sl-color-gray-5);
    transform: translateY(-5px);
    box-shadow: var(--sl-shadow-md);
  }

  .manufacturer-box h2 {
    margin-top: 0.5rem;
    margin-bottom: 0.75rem;
    color: var(--sl-color-white);
    font-size: 1.5rem;
  }

  .manufacturer-box p {
    font-size: 1rem;
    color: var(--sl-color-gray-2);
    margin-bottom: 0.5rem;
    line-height: 1.5;
  }

  .manufacturer-logo {
    width: 200px;
    height: 200px;
    object-fit: contain;
    margin-bottom: 1rem;
  }

  .category-icon {
    width: 64px;
    height: 64px;
    object-fit: contain;
    margin-bottom: 0.5rem;
  }
</style>
