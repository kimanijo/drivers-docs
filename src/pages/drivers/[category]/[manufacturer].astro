---
import { getCollection } from 'astro:content';
import StarlightPage from '@astrojs/starlight/components/StarlightPage.astro';
import yaml from 'js-yaml';
import { readFileSync, existsSync, readdirSync } from 'node:fs'; // Added readdirSync
import path from 'node:path';
import { fileURLToPath } from 'node:url'; // Added fileURLToPath
import { slugify } from '../../../utils/slugify';

export async function getStaticPaths() {
  const allDrivers = await getCollection('docs');
  const paths = [];

  for (const driver of allDrivers) {
    const category = driver.data.category || 'Uncategorized';
    const driverId = driver.id; // e.g., drivers/mounts/skywatcher/eqmod
    const driverParts = driverId.split('/');
    const driverCategorySlug = slugify(driverParts[1]); // e.g., mounts
    const driverManufacturerSlug = slugify(driverParts[2]); // e.g., skywatcher
    const driverSlug = slugify(driverParts.pop()); // e.g., eqmod

    // Find the actual cased directory name for the category
    const baseContentDirPath = path.resolve(process.cwd(), `src/content/docs/drivers`);
    let actualCategoryDirName = driverCategorySlug;

    if (existsSync(baseContentDirPath)) {
      const categoryDirs = readdirSync(baseContentDirPath, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => slugify(dirent.name));

      const foundCategoryDir = categoryDirs.find(dir => dir === driverCategorySlug);
      if (foundCategoryDir) {
        actualCategoryDirName = foundCategoryDir;
      } else {
        console.warn(`Actual category directory not found for slug: ${driverCategorySlug}`);
      }
    }

    // Find the actual cased directory name for the manufacturer
    const categoryContentDirPath = path.resolve(process.cwd(), `src/content/docs/drivers/${actualCategoryDirName}`);
    let actualManufacturerDirName = driverManufacturerSlug;

    if (existsSync(categoryContentDirPath)) {
      const manufacturerDirs = readdirSync(categoryContentDirPath, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => slugify(dirent.name));

      const foundManufacturerDir = manufacturerDirs.find(dir => dir === driverManufacturerSlug);
      if (foundManufacturerDir) {
        actualManufacturerDirName = foundManufacturerDir;
      } else {
        console.warn(`Actual manufacturer directory not found for slug: ${driverManufacturerSlug}`);
      }
    }

    const contentDirPath = path.resolve(process.cwd(), `src/content/docs/drivers/${actualCategoryDirName}/${actualManufacturerDirName}`);
    let manufacturer = 'Unknown';

    if (existsSync(contentDirPath)) {
      try {
        const filesInDir = readdirSync(contentDirPath);
        const yamlFileName = `${driverSlug}.yaml`;
        const yamlFile = filesInDir.find(file => slugify(file) === slugify(yamlFileName));

        if (yamlFile) {
          const yamlPath = path.resolve(contentDirPath, yamlFile);
          const fileContents = readFileSync(yamlPath, 'utf8');
          const driverInfo = yaml.load(fileContents);
        if (driverInfo && typeof driverInfo === 'object') {
          if ('manufacturer' in driverInfo) {
            manufacturer = driverInfo.manufacturer;
          } else if ('Manufacturer' in driverInfo) {
            manufacturer = driverInfo.Manufacturer;
          }
        }
        } else {
          console.warn(`YAML file not found for driver ${driverId} in ${contentDirPath}`);
        }
      } catch (e) {
        console.error(`Error processing YAML for ${driverId}:`, e);
      }
    } else {
      console.warn(`Content directory not found for driver ${driverId}: ${contentDirPath}`);
    }

    const slugifiedCategory = slugify(category);
    const slugifiedManufacturer = slugify(manufacturer);

    paths.push({
      params: {
        category: slugifiedCategory,
        manufacturer: slugifiedManufacturer,
      },
      props: {
        categoryName: category,
        manufacturerName: manufacturer,
      },
    });
  }

  // Filter out duplicate paths (e.g., same category and manufacturer)
  const uniquePaths = Array.from(new Set(paths.map(p => `${p.params.category}-${p.params.manufacturer}`)))
    .map(key => paths.find(p => `${p.params.category}-${p.params.manufacturer}` === key));

  return uniquePaths;
}

const { category: rawCategory, manufacturer: rawManufacturer } = Astro.params;
const category = slugify(rawCategory);
const manufacturer = slugify(rawManufacturer);
const { categoryName, manufacturerName } = Astro.props;

const allDrivers = await getCollection('docs');
const driversByManufacturer = [];

for (const driver of allDrivers) {
  const driverCategory = driver.data.category || 'Uncategorized';
  const driverId = driver.id; // e.g., drivers/mounts/skywatcher/eqmod
  const driverParts = driverId.split('/');
  const driverCategorySlug = slugify(driverParts[1]); // e.g., mounts
  const driverManufacturerSlug = slugify(driverParts[2]); // e.g., skywatcher
  const driverSlug = slugify(driverParts.pop()); // e.g., eqmod

  // Find the actual cased directory name for the category
  const baseContentDirPath = path.resolve(process.cwd(), `src/content/docs/drivers`);
  let actualCategoryDirName = driverCategorySlug;

  if (existsSync(baseContentDirPath)) {
    const categoryDirs = readdirSync(baseContentDirPath, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .map(dirent => slugify(dirent.name));

    const foundCategoryDir = categoryDirs.find(dir => dir === driverCategorySlug);
    if (foundCategoryDir) {
      actualCategoryDirName = foundCategoryDir;
    } else {
      console.warn(`Actual category directory not found for slug: ${driverCategorySlug}`);
    }
  }

  // Find the actual cased directory name for the manufacturer
  const categoryContentDirPath = path.resolve(process.cwd(), `src/content/docs/drivers/${actualCategoryDirName}`);
  let actualManufacturerDirName = driverManufacturerSlug;

  if (existsSync(categoryContentDirPath)) {
    const manufacturerDirs = readdirSync(categoryContentDirPath, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .map(dirent => slugify(dirent.name));

    const foundManufacturerDir = manufacturerDirs.find(dir => dir === driverManufacturerSlug);
    if (foundManufacturerDir) {
      actualManufacturerDirName = foundManufacturerDir;
    } else {
      console.warn(`Actual manufacturer directory not found for slug: ${driverManufacturerSlug}`);
    }
  }

  const contentDirPath = path.resolve(process.cwd(), `src/content/docs/drivers/${actualCategoryDirName}/${actualManufacturerDirName}`);
  let driverManufacturer = 'Unknown';

  if (existsSync(contentDirPath)) {
    try {
      const filesInDir = readdirSync(contentDirPath);
      const yamlFileName = `${driverSlug}.yaml`;
      const yamlFile = filesInDir.find(file => slugify(file) === slugify(yamlFileName));

      if (yamlFile) {
        const yamlPath = path.resolve(contentDirPath, yamlFile);
        const fileContents = readFileSync(yamlPath, 'utf8');
        const driverInfo = yaml.load(fileContents);
        if (driverInfo && typeof driverInfo === 'object') {
          if ('manufacturer' in driverInfo) {
            driverManufacturer = driverInfo.manufacturer;
          } else if ('Manufacturer' in driverInfo) {
            driverManufacturer = driverInfo.Manufacturer;
          }
        }
      } else {
        console.warn(`YAML file not found for driver ${driverId} in ${contentDirPath}`);
      }
    } catch (e) {
      console.error(`Error processing YAML for ${driverId}:`, e);
    }
  } else {
    console.warn(`Content directory not found for driver ${driverId}: ${contentDirPath}`);
  }

  const slugifiedDriverCategory = slugify(driverCategory);
  const slugifiedDriverManufacturer = slugify(driverManufacturer);

  if (slugifiedDriverCategory === category && slugifiedDriverManufacturer === manufacturer) {
    driversByManufacturer.push(driver);
  }
}
---

<StarlightPage frontmatter={{
  title: `${manufacturerName} Drivers in ${categoryName}`,
  template: 'splash'
}}>
  <div class="driver-grid">
    {driversByManufacturer.map(driver => {
      const driverPath = `/${slugify(driver.id.replace(/\.md$/, ''))}`;
      return (
        <a href={driverPath} class="driver-box">
          <img src={driver.data.thumbnail || `/images/drivers/${slugify(driver.data.category || 'uncategorized')}/${slugify(driver.data.title || '')}.webp`} alt={`${driver.data.title} thumbnail`} class="driver-thumbnail" />
          <h2>{driver.data.title}</h2>
        </a>
      );
    })}
  </div>
</StarlightPage>

<style>
  .driver-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 1.5rem;
    margin-top: 2rem;
  }

  .driver-box {
    border: 1px solid var(--sl-color-gray-5);
    border-radius: 0.75rem;
    padding: 0.5rem;
    background-color: var(--sl-color-gray-6);
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    text-decoration: none;
    color: inherit;
    box-shadow: var(--sl-shadow-sm);
    transition: all 0.2s ease-in-out;
  }

  .driver-box:hover {
    background-color: var(--sl-color-gray-5);
    transform: translateY(-5px);
    box-shadow: var(--sl-shadow-md);
  }

  .driver-box h2 {
    margin-top: 0.5rem;
    margin-bottom: 0.75rem;
    color: var(--sl-color-white);
    font-size: 1.5rem;
  }

  .driver-box p {
    font-size: 1rem;
    color: var(--sl-color-gray-2);
    margin-bottom: 0.5rem;
    line-height: 1.5;
  }

  .driver-thumbnail {
    width: 200px;
    height: 200px;
    object-fit: contain;
    margin-bottom: 0.5rem;
  }

  .manufacturer-logo {
    width: 96px;
    height: 96px;
    object-fit: contain;
    margin-bottom: 1rem;
  }
</style>
