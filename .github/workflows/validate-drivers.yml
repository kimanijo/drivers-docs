name: Validate Driver Documentation

on:
  pull_request:
    branches:
      - main
    paths:
      - 'src/content/docs/**'
      - 'public/images/**'

jobs:
  validate-files:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Validate Driver Structure
        run: |
          # Check for driver.md, driver.yaml, driver.webp, and optional images/ directory
          find src/content/docs -mindepth 3 -maxdepth 3 -type d | while read -r driver_dir; do
            driver_name=$(basename "$driver_dir")
            
            # Check for driver.md
            if [ ! -f "$driver_dir/$driver_name.md" ]; then
              echo "::error file=$driver_dir::Driver directory '$driver_dir' must contain '$driver_name.md'."
              exit 1
            fi

            # Check for driver.yaml
            if [ ! -f "$driver_dir/$driver_name.yaml" ]; then
              echo "::error file=$driver_dir::Driver directory '$driver_dir' must contain '$driver_name.yaml'."
              exit 1
            fi

            # Check for driver.webp
            if [ ! -f "$driver_dir/$driver_name.webp" ]; then
              echo "::error file=$driver_dir::Driver directory '$driver_dir' must contain '$driver_name.webp'."
              exit 1
            fi

            # Check for optional images directory
            if [ -d "$driver_dir/images" ]; then
              echo "Info: Driver directory '$driver_dir' contains an optional 'images/' subdirectory."
            fi
          done

          # Use regex to ensure all .md, .yaml, and .webp files are at the correct driver level and named correctly
          # Expected path format: src/content/docs/{category}/{manufacturer}/{driver}/{driver_name}.(md|yaml|webp)
          find src/content/docs -type f -regex ".*\\.\\(md\\|yaml\\|webp\\)$" -print0 | while IFS= read -r -d $'\0' file; do
            # Extract driver_name from the file path for comparison
            # Example: file = src/content/docs/category/manufacturer/driver_name/driver_name.md
            # Expected pattern for driver_name: ([^/]+)
            # Full path pattern: ^src/content/docs/[^/]+/[^/]+/([^/]+)/\1\.(md|yaml|webp)$
            if ! echo "$file" | grep -Pq "^src/content/docs/[^/]+/[^/]+/([^/]+)/\\1\\.(md|yaml|webp)$"; then
              echo "::error file=$file::Misplaced or incorrectly named driver file. Expected format: src/content/docs/{{category}}/{{manufacturer}}/{{driver_name}}/{{driver_name}}.(md|yaml|webp)"
              exit 1
            fi
          done

      - name: Validate All Image Formats
        run: |
          # Check all images in src/content/docs (including driver.webp and images/ subdirectory)
          # Ensure no other image formats are present anywhere in src/content/docs
          find src/content/docs -type f -regex ".*\\.\\(png\\|jpg\\|jpeg\\|gif\\|bmp\\)$" -print0 | while IFS= read -r -d $'\0' file; do
            echo "::error file=$file::Image file '$file' must be in .webp format. Other formats are not allowed in driver documentation directories."
            exit 1
          done

          # Check all images in public/images/manufacturers
          find public/images/manufacturers -type f ! -name "*.webp" -print0 | while IFS= read -r -d $'\0' file; do
            echo "::error file=$file::Manufacturer logo '$file' must be in .webp format."
            exit 1
          done

          # Check all images in public/images/categories
          find public/images/categories -type f ! -name "*.webp" -print0 | while IFS= read -r -d $'\0' file; do
            echo "::error file=$file::Category icon '$file' must be in .webp format."
            exit 1
          done

      - name: Validate Referenced Images Exist
        run: |
          # Validate category logos based on directory names
          find src/content/docs -mindepth 1 -maxdepth 1 -type d | while read -r category_dir; do
            category_name=$(basename "$category_dir")
            category_image="public/images/categories/${category_name}.webp"
            if [ ! -f "$category_image" ]; then
              echo "::error file=$category_dir::Category logo for directory '$category_name' not found at '$category_image'."
              exit 1
            fi
          done

          # Validate manufacturer logos based on directory names
          find src/content/docs -mindepth 2 -maxdepth 2 -type d | while read -r manufacturer_dir; do
            manufacturer_name=$(basename "$manufacturer_dir")
            manufacturer_image="public/images/manufacturers/${manufacturer_name}.webp"
            if [ ! -f "$manufacturer_image" ]; then
              echo "::error file=$manufacturer_dir::Manufacturer logo for directory '$manufacturer_name' not found at '$manufacturer_image'."
              exit 1
            fi
          done
